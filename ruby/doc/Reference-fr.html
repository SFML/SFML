<html>
<title>RubySFML Documentation</title>
<style type="text/css">
h4,h5,ul {margin: 5px}
pre {background: #F0F0F0}
.comment {color: #8080FF}
.text {color: green}
.keyword {color: purple}
</style>
<head>
</head>
<body>
	<h1>Introduction</h1>
	<p>Cette documentation est assez courte, mais étant donné que cette extension n'est qu'une simple encapsulation des classes C++ de SFML, il est conseillé de se baser sur la documentation SFML pour obtenir plus de détails sur les classes et les fonctions. Cette documentation a simplement pour but de détailler les classes et fonctions qui sont présentes dans l'extension RubySFML, ainsi que de décrire les changements qui ont été effectués durant la traduction C++ vers Ruby.</p>
	<p>Etant donné que Ruby ne supporte pas les threads et possède ses propres classes pour le réseau, seules certaines classes des modules système, fenêtrage, graphisme et audio sont exposées. Pour la plupart des classes, les seuls changements effectués ont été de faire débuter les noms des fonctions par une minuscule. Pour les classes possédant des accesseurs simples, ceux-ci ont souvent été abandonnés pour utiliser une syntaxe plus simple (par exemple sprite.left = ...). Quelques fonctions to_i, to_f et to_s ont étalement été ajoutées là où cela semblait pertinent. Enfin, un itérateur "each" a été ajouté à VideoMode.</p>
	<p>En plus des classes C++ exposées, deux classes utiles ont également été ajoutées à RubySFML.rb, l'une pour afficher des sprites à base de tuiles, et l'autre pour gérer les sprites utilisant des calculs de vitesse / acceleration (respectivement TSprite et VSprite).</p>

    <h3>Astuces pour les utilisateurs Windows</h3>
	<p>Pour les utilisateurs Windows, nous regrettons de ne pas pouvoir être compatibles avec l'installeur "one-click", mais celui-ci est compilé avec Visual Studio 6.0, qui est ridiculeusement vieux et incompatible avec les bibliothèques SFML. Il existe une version gratuite de Visual Studio 2005, et les sources de Ruby compilent parfaitement avec celle-ci, on ne peut donc trouver aucune bonne excuse à l'installeur pour toujours utiliser Visual C++ 6.0.</p>
    <p>La bonne nouvelle est que vous pouvez distribuer vos applications dans une archive qui se suffit à elle-même, en incluant les répertoires "bin" et "lib" qui sont inclus dans la version Windows de cette extension. Ajoutez un installeur simple qui crée une icône du menu démarrer exécutant "%install_path%\bin\ruby.exe %install_path%\my_game.rb", et tout sera parfait. Oh, encore une chose, OpenAL doit être installé pour exécuter les programmes utilisant RubySFML. Heureusement, il s'agit d'un installeur extrêmement petit et simple, et vous pourrez sans problème le fournir dans vos installations ou donner un lien pour le télécharger. Tout ceci évite à vos utilisateurs d'avoir à télécharger / exécuter l'installeur "one-click", installer toutes les extensions nécessaires, s'occuper des problèmes de compatibilité, etc. Il est probable que très peu d'utilisateurs Windows utilisent vos applications si vous ne leur fournissez pas tout ce dont ils ont besoin, c'est donc probablement mieux de cette manière.</p>
    <p><b>Note :</b> cette compilation perso de Ruby ne contient pas gems et zlib (qui est recquis par gems), mais aucune autre extension n'est installée. N'hésitez pas à installer n'importe quelle autre gems / extension dont vous auriez besoin (les gems mswin32 compilés avec Visual Studio 6.0 ne fonctionneront probablement pas). Gardez en tête que beaucoup de gems ont une documentation conséquente, des exemples et des répertoires de test. Supprimer ces répertoires innutiles, ainsi que le répertoire cache des gems, peut réduire de manière significative la taille des fichiers que vous distribuez.</p>

	<h3>Exemple de code RubySFML</h3>
<pre>
<span class="comment"># On inclut l'extension RubySFML</span>
<span class="keyword">require</span> "<span class="text">RubySFML</span>"
<span class="keyword">include</span> SFML

<span class="comment"># On crée la fenêtre principale</span>
mode = VideoMode.new 800, 600, 32
window = RenderWindow.new mode, "<span class="text">RubySFML Test</span>", false

<span class="comment"># On charge un sprite à afficher</span>
image = Image.new "<span class="text">cute_image.jpg</span>"
sprite = Sprite.new image
 
<span class="comment"># On crée une chaîne graphique à afficher</span>
text = Text.new "<span class="text">Hello SFML</span>", "<span class="text">arial.ttf</span>", 50
 
<span class="comment"># On charge une musique et on commence à la jouer</span>
music = Music.new "<span class="text">nice_music.ogg</span>"
music.play
 
<span class="comment"># On démarre la boucle principale</span>
running = true
<span class="keyword">while</span> running
	<span class="keyword">while</span> event = window.getEvent
		running = false <span class="keyword">if</span> event.type == Event::Close
	<span class="keyword">end</span>
 
	<span class="comment"># On dessine le sprite, le texte, puis on met à jour la fenêtre</span>
	window.draw sprite
	window.draw text
	window.display
<span class="keyword">end</span>
</pre>

	<h3>Modules RubySFML</h3>
	<ul>
		<li><b><a href="#global">SFML</a</b> - Contient toutes les classes, modules et fonctions globales SFML</li>
		<li><b>SFML::Event</b> - Contient les constantes associées aux évènements SFML.</li>
		<li><b>SFML::Key</b> - Contient les constantes pour tous les codes de touches clavier SFML.</li>
		<li><b>SFML::Mouse</b> - Contient les constantes pour tous les codes de boutons souris SFML.</li>
	</ul>

	<h3>Classes RubySFML</h3>
	<ul>
		<li><a href="#clock">SFML::Clock</a> - Une horloge système utilisant les timers haute performance lorsqu'ils sont accessibles</li>
		<li><a href="#color">SFML::Color</a> - Une classe de couleurs RGBA très simple</li>
		<li><a href="#drawable">SFML::Drawable</a> - Une classe abstraite représentant les objets 2D utilisés dans une Renderwindow </li>
		<li><a href="#event">SFML::Event</a> - Une classe représentant les différents évènements système (clavier, souris, etc.)</li>
		<li><a href="#floatrect">SFML::FloatRect</a> - Un simple rectangle composé de 4 coordonnées flottantes</li>
		<li><a href="#image">SFML::Image</a> - Une classe pour gérer les fichiers images et les textures</li>
		<li><a href="#input">SFML::Input</a> - Une classe pour récupérer l'état des périphériques d'entrée (clavier, souris, joystick)</li>
		<li><a href="#intrect">SFML::IntRect</a> - Un simple rectangle composé de 4 coordonnées entières</li>
		<li><a href="#music">SFML::Music</a> - Une classe pour jouer des musiques en streaming</li>
		<li><a href="#postfx">SFML::PostFX</a> - Une classe pour gérer les shaders post-rendu</li>
		<li><a href="#renderwindow">SFML::RenderWindow</a> - Une sous-classe de Window wui permet d'afficher les objets 2D tels que sprites et texte</li>
		<li><a href="#sound">SFML::Sound</a> - Une classe pour jouer des sons</li>
		<li><a href="#soundbuffer">SFML::SoundBuffer</a> - Une classe pour stocker des échantillons audio</li>
		<li><a href="#soundbufferrecorder">SFML::SoundBufferRecorder</a> - Une classe pour enregistrer du son à partir d'un périphérique de capture audio, comme un microphone</li>
		<li><a href="#sprite">SFML::Sprite</a> - Une classe pour gérer et afficher des sprites 2D</li>
		<li><a href="#text">SFML::Text</a> - Une classe pour gérer et afficher du texte 2D</li>
		<li><a href="#videomode">SFML::VideoMode</a> - Une classe pour gérer les différents modes vidéo</li>
		<li><a href="#view">SFML::View</a> - Une classe pour gérer la caméra 2D dans une RenderWindow</li>
		<li><a href="#window">SFML::Window</a> - Une classe pour créer et gérer une fenêtre capable d'afficher un rendu OpenGL (gère également les entrées et les évènements)</li>
	</ul>

	<h3>Fonctions RubySFML (par module / classe)</h3>
	<hr/>
	<h4><a name="global">SFML</a></h4>
	<ul>
		<li><b>checkExtension(str)</b> - Renvoie vrai si l'extension OpenGL donnée est supportée.</li>
		<li><b>getMaxTextureSize</b> - Renvoie la taille maximum de texture.</li>
		<li><b>getMaxTextureUnits</b> - Renvoie le nombre maximum d'unités de textures utilisables.</li>
	</ul>

	<hr/>
	<h4><a name="clock">SFML::Clock</a></h4>
	<ul>
		<li><b>initialize()</b> - Constructeur par défaut</li>
		<li><b>to_s</b> - Renvoie une chaîne formatée décrivant l'objet (pour déboguage)</li>
		<li><b>reset</b> - Remet à zéro l'horloge</li>
		<li><b>elapsedTime,to_f</b> - Renvoie le nombre de secondes écoulées depuis le dernier appel à reset</li>
	</ul>

	<hr/>
	<h4><a name="color">SFML::Color</a></h4>
	<ul>
		<li><b>initialize()</b> - Constructeur par défaut</li>
		<li><b>initialize(n)</b> - Construit l'objet à partir d'une couleur 32 bits entière non signée (0x12345678 donne r=0x78, g=0x56, b=0x34, a=0x12)</li>
		<li><b>initialize(r, g, b, a=255)</b> - Construit la couleur à partir de ses composantes</li>
		<li><b>to_s</b> - Renvoie une chaîne formatée décrivant l'objet (pour déboguage)</li>
		<li><b>r, g, b, a</b> - Renvoie les composantes r, g, b et a (respectivement)</li>
		<li><b>r=, g=, b=, a=</b> - Affecte les composantes r, g, b et a (respectivement)</li>
		<li><b>toRGBA</b> -Renvoie les 4 composantes de la couleur sous forme d'entier RGBA 32 bits non signé (0x12345678 donne r=0x78, g=0x56, b=0x34, a=0x12)</li>
		<li><b>to_i</b> - Alias pour toRGBA</li>
	</ul>

	<hr/>
	<h4><a name="drawable">SFML::Drawable</a></h4>
	<ul>
		<li><b>initialize(left=0, top=0, scale=1, rotation=0, color=Color.White)</b> - Initialise les différents membres (scale peut être un nombre ou un tableau de deux nombres)</li>
		<li><b>to_s</b> - Renvoie une chaîne formatée décrivant l'objet (pour déboguage)</li>
		<li><b>left, left=</b> - Modifie / récupère la position x de l'objet</li>
		<li><b>top, top=</b> - Modifie / récupère la position y de l'objet</li>
		<li><b>scale, scale=</b> - Modifie / récupère le facteur d'échelle de l'objet (renvoie un tableau, mais peut être initialisé à partir d'un tableau ou d'un seul nombre)</li>
		<li><b>color, color=</b> - Modifie / récupère la couleur de l'objet</li>
		<li><b>rotation, rotation=</b> - Modifie / récupère l'angle de rotation (en degrés)</li>
		<li><b>upVector</b> - Récupère le vecteur "haut" de l'objet (basé sur son angle de rotation)</li>
		<li><b>rightVector</b> - Récupère le vecteur "droite" de l'objet (basé sur son angle de rotation)</li>
		<li><b>setRotationCenter(x, y)</b> - Change le centre de rotation de l'objet</li>
		<li><b>move(x, y)</b> - Déplace l'objet horizontalement et verticalement</li>
		<li><b>rotate(a)</b> - Fait tourner l'objet</li>
		<li><b>render(window)</b> - (virtuelle) à redéfinir pour personnaliser le rendu de l'objet</li>
	</ul>

	<hr/>
	<h4><a name="event">SFML::Event</a></h4>
	<h5>Pour tous les types d'évènements</h5>
	<ul>
		<li><b>initialize</b> - Ne prend aucun paramètre</li>
		<li><b>to_s</b> - Renvoie une chaîne formatée décrivant l'objet (pour déboguage)</li>
		<li><b>type</b> - Renvoie le type de l'évènement</li>
	</ul>
	<h5>Pour les évènements de type Event::TextEntered</h5>
	<ul>
		<li><b>char</b> - Renvoie le caractère entré (uniquement pour les évènements Event::TextEntered)</li>
	</ul>
	<h5>Pour les évènements de type Event::KeyPressed et Event::KeyReleased</h5>
	<ul>
		<li><b>code</b> - Renvoie le code de la touche (uniquement pour les évènements Event::KeyPressed et Event::KeyReleased)</li>
		<li><b>alt</b> - Renvoie vrai si la touche Alt est enfoncée (uniquement pour les évènements Event::KeyPressed et Event::KeyReleased)</li>
		<li><b>control</b> - Renvoie vrai si la touche Control est enfoncée (uniquement pour les évènements Event::KeyPressed et Event::KeyReleased)</li>
		<li><b>shift</b> - Renvoie vrai si la touche Shift est enfoncée (uniquement pour les évènements Event::KeyPressed et Event::KeyReleased)</li>
	</ul>
	<h5>Pour les évènements de type souris et joystick</h5>
	<ul>
		<li><b>delta</b> - Renvoie le déplacement de la molette souris (uniquement pour les évènements Event::MouseWheelMoved)</li>
		<li><b>buttons</b> - Renvoie l'état des boutons de la souris (uniquement pour les évènements souris)</li>
		<li><b>button</b> - Renvoie l'état des boutons du joystick (uniquement pour les évènements joystick)</li>
		<li><b>x</b> - Renvoie la position x (uniquement pour les évènements souris et joystick)</li>
		<li><b>y</b> - Renvoie la position y (uniquement pour les évènements souris et joystick)</li>
		<li><b>z</b> - Renvoie la position z (uniquement pour les évènements joystick)</li>
	</ul>
	<h5>Pour les évènements de type Event::Resize</h5>
	<ul>
		<li><b>width</b> - Renvoie la nouvelle largeur de la fenêtre (uniquement pour les évènements Event::Resize)</li>
		<li><b>height</b> - Renvoie la nouvelle hauteur de la fenêtre (uniquement pour les évènements Event::Resize)</li>
	</ul>

	<hr/>
	<h4><a name="floatrect">SFML::FloatRect</a></h4>
	<ul>
		<li><b>initialize()</b> - Constructeur par défaut</li>
		<li><b>initialize(left, top, right, bottom)</b> - Initialise les coordonnées du rectangle (gauche, haut, droite, bas)</li>
		<li><b>to_s</b> - Renvoie une chaîne formatée décrivant l'objet (pour déboguage)</li>
		<li><b>left, l</b> - Renvoie la position x gauche</li>
		<li><b>left=, l=</b> - Modifie la position x gauche</li>
		<li><b>top, t</b> - Renvoie la position y haute</li>
		<li><b>top=, t=</b> - Modifie la position y haute</li>
		<li><b>right, r</b> - Renvoie la position x droite</li>
		<li><b>right=, r=</b> - Modifie la position x droite</li>
		<li><b>bottom, b</b> - Renvoie la position y basse</li>
		<li><b>bottom=, b=</b> - Modifie la position y basse</li>
		<li><b>width, w</b> - Renvoie la largeur du rectangle</li>
		<li><b>height, h</b> - Renvoie la hauteur du rectangle</li>
		<li><b>contains(x, y)</b> - Renvoie vrai si le point (x, y) est à l'intérieur du rectangle</li>
		<li><b>intersects(rect)</b> - Renvoie l'intersection de deux rectangles (nil s'il n'y a aucune intersection)</li>
	</ul>

	<hr/>
	<h4><a name="image">SFML::Image</a></h4>
	<ul>
		<li><b>initialize</b> - Crée une image vide</li>
		<li><b>initialize(image)</b> - Crée une copie d'une image</li>
		<li><b>initialize(path)</b> - Charge une image à partir du fichier spécifié (lève une erreur RuntimeError si échoue)</li>
		<li><b>initialize(w, h, c=Color.Black)</b> - Crée une image vide avec les dimensions et la couleur données</li>
		<li><b>to_s</b> - Renvoie une chaîne formatée décrivant l'objet (pour déboguage)</li>
		<li><b>getValidTextureSize(s)</b> - (statique) Renvoie la taille de texture valide la plus proche &gt;= s</li>
		<li><b>width, w</b> - Renvoie la largeur de l'image</li>
		<li><b>height, h</b> - Renvoie la hauteur de l'image</li>
		<li><b>smooth=, setSmooth(bool)</b> - Modifie les paramètres de lissage de l'image (true pour activer, false pour désactiver)</li>
		<li><b>repeat=, setRepeat(bool)</b> - Modifie les paramètres de répétition de l'image (true pour activer, false pour désactiver)</li>
		<li><b>loadFromFile(path)</b> - Charge l'image à partir du fichier spécifié (renvoie faux si échoue)</li>
		<li><b>saveToFile(path)</b> - Sauvegarde l'image dans le fichier spécifié</li>
		<li><b>create(w, h, c=Color.Black)</b> - Crée une image vide avec les dimensions et la couleur données</li>
		<li><b>createMaskFromColor(color, a=0)</b> - Remplace la valeur alpha (transparence) de tous les pixels ayant la couleur spécifiée, par la valeur de transparence donnée</li>
		<li><b>resize(w, h, c=Color.Black)</b> - Redimensionne l'image. Si celle-ci est agrandie, les nouveaux pixels ont la couleur spécifiée</li>
		<li><b>getPixel(x, y), [x,y]</b> - Renvoie la couleur du pixel (x, y)</li>
		<li><b>setPixel(x, y, c), [x,y]=</b> - Change la couleur du pixel (x, y) par la couleur spécifiée</li>
		<li><b>update</b> - Met à jour l'image en mémoire vidéo (à appeler après toute modification manuelle des pixels)</li>
		<li><b>bind</b> - Utilise l'image pour le rendu (à appeler si vous utiliser l'image en tant que texture pour un rendu OpenGL)</li>
		<li><b>getTexCoords(rect)</b> - Convertit des coordonnées entières en pixel, en coordonnées flottantes de texture</li>
	</ul>

	<hr/>
	<h4><a name="input">SFML::Input</a></h4>
	<ul>
		<li><b>initialize</b> - Constructeur par défaut</li>
		<li><b>isKeyDown(key)</b> - Renvoie vrai si la touche spécifiée est enfoncée</li>
		<li><b>isMouseButtonDown(button)</b> - Renvoie vrai si le bouton souris spécifié est enfoncé</li>
		<li><b>isJoystickButtonDown(n, button)</b> - Renvoie vrai si le bouton du joystick n spécifié est enfoncé</li>
		<li><b>getMouseX</b> - Renvoie la position x actuelle de la souris</li>
		<li><b>getMouseY</b> - Renvoie la position y actuelle de la souris</li>
		<li><b>getJoystickX(n)</b> - Renvoie la position x actuelle du joystick n</li>
		<li><b>getJoystickY(n)</b> - Renvoie la position y actuelle du joystick n</li>
		<li><b>getJoystickZ(n)</b> - Renvoie la position z actuelle du joystick n</li>
	</ul>

	<hr/>
	<h4><a name="intrect">SFML::IntRect</a></h4>
	<ul>
		<li><b>initialize()</b> - Constructeur par défaut</li>
		<li><b>initialize(left, top, right, bottom)</b> - Initialise les coordonnées du rectangle (gauche, haut, droite, bas)</li>
		<li><b>to_s</b> - Renvoie une chaîne formatée décrivant l'objet (pour déboguage)</li>
		<li><b>left, l</b> - Renvoie la position x gauche</li>
		<li><b>left=, l=</b> - Modifie la position x gauche</li>
		<li><b>top, t</b> - Renvoie la position y haute</li>
		<li><b>top=, t=</b> - Modifie la position y haute</li>
		<li><b>right, r</b> - Renvoie la position x droite</li>
		<li><b>right=, r=</b> - Modifie la position x droite</li>
		<li><b>bottom, b</b> - Renvoie la position y basse</li>
		<li><b>bottom=, b=</b> - Modifie la position y basse</li>
		<li><b>width, w</b> - Renvoie la largeur du rectangle</li>
		<li><b>height, h</b> - Renvoie la hauteur du rectangle</li>
		<li><b>contains(x, y)</b> - Renvoie vrai si le point (x, y) est à l'intérieur du rectangle</li>
		<li><b>intersects(rect)</b> - Renvoie l'intersection de deux rectangles (nil s'il n'y a aucune intersection)</li>
	</ul>

	<hr/>
	<h4><a name="music">SFML::Music</a></h4>
	<ul>
		<li><b>initialize(bufSize=44100)</b> - Permet de spécifier la taille du tampon interne (à modifier si vous rencontrez des problèmes de performances ou de saccades)</li>
		<li><b>initialize(path)</b> - Ouvre la musique à partir du fichier spécifié (lève une erreur RuntimeError si échoue).</li>
		<li><b>to_s</b> - Renvoie une chaîne formatée décrivant l'objet (pour déboguage)</li>
		<li><b>loop, loop=</b> - Renvoie / modifie un booléen indiquant si la musique doit boucler lorsqu'elle est terminée</li>
		<li><b>duration</b> - Renvoie la durée totale de la musique, en secondes</li>
		<li><b>channels</b> - Renvoie le nombre de canaux de la musique (1 = mono, 2 = stereo).</li>
		<li><b>sampleRate</b> - Renvoie le taux d'échantillonnage de la musique (44100 = qualité CD).</li>
		<li><b>status</b> - Renvoie l'état de lecture de la musique (Sound::Stopped, Sound::Paused, Sound::Playing).</li>
		<li><b>open(path)</b> - Ouvre la musique à partir du fichier spécifié (renvoie faux si échoue).</li>
		<li><b>play</b> - Démarre la lecture de la musique</li>
		<li><b>stop</b> - Stoppe la lecture de la musique</li>
	</ul>

	<hr/>
	<h4><a name="postfx">SFML::PostFX</a></h4>
	<ul>
		<li>(Hérite de toutes les fonctions de <a href="#drawable">SFML::Drawable</a>)</li>
		<li><b>initialize()</b> - Constructeur par défaut</li>
		<li><b>initialize(path)</b> - Charge le fichier effet spécifié</li>
		<li><b>initialize(postFX)</b> - Crée une copie d'un objet PostFX</li>
		<li><b>loadFromFile(path)</b> - Charge le fichier effet spécifié (renvoie faux si échoue)</li>
		<li><b>setParameter(name, x, y=nil, z=nil, w=nil)</b> - Change la valeur d'un paramètre de l'effet</li>
		<li><b>setTexture(name, image)</b> - Change une texture de l'effet</li>
	</ul>

	<hr/>
	<h4><a name="renderwindow">SFML::RenderWindow</a></h4>
	<ul>
		<li><b>initialize(mode, title, style=Window::Resizable, antialias=0)</b> - Crée une fenêtre de rendu 2D en utilisant le mode vidéo, le titre et le style spécifiés</li>
		<li><b>to_s</b> - Renvoie une chaîne formatée décrivant l'objet (pour déboguage)</li>
		<li><b>width, w</b> - Renvoie la largeur de la fenêtre</li>
		<li><b>height, h</b> - Renvoie la hauteur de la fenêtre</li>
		<li><b>input</b> - Renvoie l'objet <a href="#input">SFML::Input</a> associé à cette fenêtre</li>
		<li><b>frameTime</b> - Renvoie le temps écoulé depuis le dernier rafraîchissement</li>
		<li><b>stencilBits</b> - Renvoie le nombre de bits alloués au tampon stencil</li>
		<li><b>depthBits</b> - Renvoie le nombre de bits alloués au tampon de profondeur</li>
		<li><b>view, view=</b> - Renvoie / modifie l'objet <a href="#view">SFML::View</a> courant (camera 2D)</li>
		<li><b>backgroundColor=</b> - Modifie la couleur de fond de la fenêtre</li>
		<li><b>getEvent</b> - Renvoie le prochain évènement en attente dans la file d'évènements (ou nil s'il n'y en a aucun)</li>
		<li><b>useVerticalSync(bool)</b> - Active / désactive la synchronisation verticale</li>
		<li><b>showMouseCursor(bool)</b> - Affiche / cache le curseur souris sur la fenêtre</li>
		<li><b>display</b> - Met à jour la fenêtre à l'écran</li>
		<li><b>beginOpenGL</b> - Sauvegarde les états OpenGL internes avant que vous ne placiez des appels OpenGL</li>
		<li><b>endOpenGL</b> - Restaure les états OpenGL internes après que vous ayiez placé des appels OpenGL</li>
		<li><b>capture</b> - Prend une capture d'écran et la renvoie sous forme d'image</li>
		<li><b>draw(obj)</b> - Affiche dans la fenêtre tout objet dérivant de <a href="#drawable">SFML::Drawable</a></li>
		<li><b>setFramerateLimit</b> - Fixe une limite de rafraîchissement, en images par seconde (0 pour désactiver)</li>
	</ul>

	<hr/>
	<h4><a name="sound">SFML::Sound</a></h4>
	<ul>
		<li><b>initialize(sound)</b> - Crée une copie d'un objet son</li>
		<li><b>initialize(buffer=nil, loop=false, pitch=1, volume=100, x=0, y=0, z=0)</b> - Crée un objet son en utilisant le tampon audio et les autres paramètres spécifiés</li>
		<li><b>to_s</b> - Renvoie une chaîne formatée décrivant l'objet (pour déboguage)</li>
		<li><b>buffer, buffer=</b> - Renvoie / modifie le <a href="#soundbuffer">SFML::SoundBuffer</a> de cet objet</li>
		<li><b>loop, loop=</b> - Renvoie / modifie l'état de bouclage du son</li>
		<li><b>pitch, pitch=</b> - Renvoie / modifie le pitch du son</li>
		<li><b>volume, volume=</b> - Renvoie / modifie le volume du son</li>
		<li><b>position, position=</b> -Renvoie / modifie la position du son (utilise un tableau de 3 valeurs)</li>
		<li><b>status</b> - Renvoie l'état de lecture du son (Sound::Stopped, Sound::Paused, Sound::Playing).</li>
		<li><b>playingOffset</b> - Renvoie la position de lecture courante du son (en secondes).</li>
		<li><b>play</b> - Démarre la lecture du son</li>
		<li><b>pause</b> - Met ne pause le son</li>
		<li><b>stop</b> - Stoppe la lecture du son</li>
	</ul>

	<hr/>
	<h4><a name="soundbuffer">SFML::SoundBuffer</a></h4>
	<ul>
		<li><b>initialize()</b> - Constructeur par défaut</li>
		<li><b>initialize(soundBuffer)</b> - Crée une copie d'un objet SoundBuffer</li>
		<li><b>initialize(path)</b> - Charge le tampon sonore à partir du fichier spécifié (lève une erreur RuntimeError si échoue).</li>
		<li><b>to_s</b> - Renvoie une chaîne formatée décrivant l'objet (pour déboguage)</li>
		<li><b>samples</b> - Renvoie les échantillons sonores bruts sous forme de chaîne Ruby</li>
		<li><b>samplesCount</b> - Renvoie le nombre d'échantillons sonores du tampon</li>
		<li><b>samplesRate</b> - Renvoie le taux d'échantillonnage (nombre d'échantillons par seconde pour chaque canal)</li>
		<li><b>channels</b> - Renvoie le nombre de canaux (1 = mono, 2 = stereo)</li>
		<li><b>duration</b> - Renvoie la durée du tampon sonore (en secondes)</li>
		<li><b>loadFromFile(path)</b> - Charge le tampon sonore à partir du fichier spécifié (renvoie faux si échoue)</li>
		<li><b>saveToFile(path)</b> - Sauvegarde le tampon sonore dans le fichier spécifié (renvoie faux si échoue)</li>
		<li><b>loadFromMemory(samples, samplesCount, channels, sampleRate)</b> - Construit le tampon sonore à partir d'échantillons bruts en mémoire</li>
	</ul>

	<hr/>
	<h4><a name="soundbufferrecorder">SFML::SoundBufferRecorder</a></h4>
	<ul>
		<li><b>initialize()</b> - Constructeur par défaut</li>
		<li><b>canCapture</b> - (statique) Renvoie vrai si le système est capable d'effectuer les captures audio</li>
		<li><b>start(sampleRate=44100)</b> - Démarre la capture audio</li>
		<li><b>stop</b> - Stoppe la capture audio</li>
		<li><b>buffer</b> - Renvoie l'objet SoundBuffer contenant le son capturé</li>
		<li><b>sampleRate</b> - Renvoie le taux d'échantillonnage utilisé pour la capture</li>
	</ul>

	<hr/>
	<h4><a name="sprite">SFML::Sprite</a></h4>
	<ul>
		<li>(Hérite de toutes les fonctions de <a href="#drawable">SFML::Drawable</a>)</li>
		<li><b>initialize()</b> - Constructeur par défaut</li>
		<li><b>initialize(image, left=0, top=0, scale=1, rotation=0, c=Color.White)</b> - Construit le sprite à partir de l'image et des autres paramètres donnés (le paramètre scale peut être un nombre simple ou un tableau de deux nombres)</li>
		<li><b>to_s</b> - Renvoie une chaîne formatée décrivant l'objet (pour déboguage)</li>
		<li><b>width, w</b> - Renvoie la largeur du sprite (affectée par subRect et scale)</li>
		<li><b>height, h</b> - Renvoie la hauteur du sprite (affectée par subRect et scale)</li>
		<li><b>right, right=</b> - Renvoie / modifie la position x droite du sprite</li>
		<li><b>bottom, bottom=</b> - Renvoie / modifie la position y basse du sprite</li>
		<li><b>x, x=</b> - Renvoie / modifie la position x centrale du sprite</li>
		<li><b>y, y=</b> - Renvoie / modifie la position y centrale du sprite</li>
		<li><b>image, image=</b> - Renvoie / modifie l'image utilisée par le sprite</li>
		<li><b>subRect, subRect=</b> - Renvoie / modifie le sous-rectangle de l'image source utilisé pour le sprite</li>
		<li><b>getPixel(x,y), [x,y]</b> - Renvoie la couleur d'un pixel du sprite relativement à son sous-rectangle ([0, 0] serait le pixel haut-gauche du sous-rectangle)</li>
		<li><b>radius</b> - Renvoie le rayon du cercle englobant du sprite (basé sur sa hauteur et sa largeur)</li>
		<li><b>distance(sprite)</b> - Renvoie la distance entre les centres de deux sprites</li>
		<li><b>render(window)</b> - (virtuelle) A redéfinir pour effectuer un rendu personnalisé</li>
	</ul>

	<hr/>
	<h4><a name="text">SFML::Text</a></h4>
	<ul>
		<li>(Hérite de toutes les fonctions de <a href="#drawable">SFML::Drawable</a>)</li>
		<li><b>initialize(str="", font="", size=32)</b> - Initialise l'objet Text avec le texte, la police et la taille spécifiés</li>
		<li><b>preloadFont(font, size)</b> - (statique) Force le chargement de la police avant sa première utilisation</li>
		<li><b>text, text=</b> - Renvoie / modifie la chaîne à afficher</li>
		<li><b>font, font=</b> - Renvoie / modifie la police de caractères à utiliser</li>
		<li><b>size, size=</b> - Renvoie / modifie la taille du texte</li>
		<li><b>getRect</b> - Renvoie le rectangle englobant de la chaîne graphique</li>
		<li><b>render(window)</b> - (virtuelle) A redéfinir pour effectuer un rendu personnalisé</li>
	</ul>

	<hr/>
	<h4><a name="videomode">SFML::VideoMode</a></h4>
	<ul>
		<li><b>initialize()</b> - Constructeur par défaut</li>
		<li><b>initialize(w, h, bpp=32)</b> - Crée un mode vidéo avec les dimensions et la profondeur (bits par pixel) spécifiées</li>
		<li><b>desktop</b> - (statique) Renvoie le mode vidéo actuel du bureau</li>
		<li><b>each</b> - (statique) Itère sur tous les modes vidéo plein écran valides</li>
		<li><b>to_s</b> - Renvoie une chaîne formatée décrivant l'objet (pour déboguage)</li>
		<li><b>width, w, width=, w=</b> - Renvoie / modifie la largeur du mode vidéo</li>
		<li><b>height, h, height=, h=</b> - Renvoie / modifie la hauteur du mode vidéo</li>
		<li><b>bitsPerPixel, bpp, bitsPerPixel=, bpp=</b> - Renvoie / modifie la profondeur (bits par pixels) du mode vidéo</li>
		<li><b>isValid</b> - Renvoie vrai si le mode est un mode plein écran valide</li>
	</ul>

	<hr/>
	<h4><a name="view">SFML::View</a></h4>
	<ul>
		<li><b>initialize()</b> - Constructeur par défaut</li>
		<li><b>initialize(left, top, width, height, zoom=1)</b> - Initialise la vue avec la position, taille et le zomm spécifiés</li>
		<li><b>to_s</b> - Renvoie une chaîne formatée décrivant l'objet (pour déboguage)</li>
		<li><b>left, l, left=, l=</b> - Renvoie / modifie la position x gauche de la vue</li>
		<li><b>top, t, top=, t=</b> - Renvoie / modifie la position y haute de la vue</li>
		<li><b>width, w, width=, w=</b> - Renvoie / modifie la largeur de la vue</li>
		<li><b>height, h, height=, h=</b> - Renvoie / modifie la hauteur de la vue</li>
		<li><b>zoom, zoom=</b> - Renvoie / modifie le facteur de zoom de la vue</li>
	</ul>

	<hr/>
	<h4><a name="window">SFML::Window</a></h4>
	<ul>
		<li><b>initialize(mode, title, style=Window::Resizable, antialias=0)</b> - Crée une fenêtre en utilisant le mode vidéo, le titre et le style spécifiés</li>
		<li><b>to_s</b> - Renvoie une chaîne formatée décrivant l'objet (pour déboguage)</li>
		<li><b>width, w</b> - Renvoie la largeur de la fenêtre</li>
		<li><b>height, h</b> - Renvoie la hauteur de la fenêtre</li>
		<li><b>input</b> - Renvoie l'objet <a href="#input">SFML::Input</a> associé à cette fenêtre</li>
		<li><b>frameTime</b> - Renvoie le temps écoulé depuis le dernier rafraîchissement</li>
		<li><b>stencilBits</b> - Renvoie le nombre de bits alloués au tampon stencil</li>
		<li><b>depthBits</b> - Renvoie le nombre de bits alloués au tampon de profondeur</li>
		<li><b>getEvent</b> - Renvoie le prochain évènement en attente dans la file d'évènements (ou nil s'il n'y en a aucun)</li>
		<li><b>useVerticalSync(bool)</b> - Active / désactive la synchronisation verticale</li>
		<li><b>showMouseCursor(bool)</b> - Affiche / cache le curseur souris sur la fenêtre</li>
		<li><b>display</b> - Met à jour la fenêtre à l'écran</li>
		<li><b>setCurrent</b> - Rend la fenêtre courante active pour le rendu</li>
		<li><b>setFramerateLimit</b> - Fixe une limite de rafraîchissement, en images par seconde (0 pour désactiver)</li>
	</ul>

</body>
</html>
